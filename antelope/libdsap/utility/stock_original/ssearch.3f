'\" te


.\" $Name $Revision: 1.1.1.1 $ $Date: 1997/04/12 04:19:02 $
.EQ
delim $$
.EN
.TH SSEARCH 3F "$Date: 1997/04/12 04:19:02 $"
.SH NAME
ssearch \- binary search of index
.SH SYNOPSIS
.nf
integer ssearch ( key, keysize, a, n, unique, compare, private, ns, ne ) 
{integer, real, ...} key
int keysize
{integer, real, ...} a(n)
integer n
integer unique
integer compare
external compare
{integer, real, ...} private
integer *ns
integer *ne 
.fi
.SH DESCRIPTION
\fBSsearch\fR is a binary search of a sorted list, with allows the
list to contain repeated values.  Its input arguments are:
.IP \fIkey\fR
.IP \fIkeysize\fR
the key for which to search and its size
.IP \fIa\fR
.IP \fIn\fR
the array to search and its size 
.IP \fIunique\fR
a flag to indicate that the key is unique in the table
(or perhaps, that you only need a match, not all matches).
The search for the boundaries of the set of matching keys adds
significantly to the cost of the search.
.IP \fIcompare\fR
.IP \fIprivate\fR
The comparison routine, and a private array or value which 
is passed to the comparison routine.  The comparison routine is
called like "compare ( key1, key2, private )"
where key1 and key2 are elements of the array.
Compare should return an integer less
than, equal to, or greater  than  zero  if
the first argument is respectively less than, equal to, or
greater than the second.
.IP \fIns\fR
.IP \fIne\fR
\fIns\fR and \fIne\fR bracket the range in the index which 
matches the key; ie, if a match is found, then all the keys in the
index from ns to ne inclusive match the key.  If no matches are found, 
ns < ne, and the key could be inserted immediately following ne.
.SH EXAMPLE
.nf
moser% cat tryshell.f
	implicit none
	integer n 
	parameter ( n = 17 ) 
	integer a(n) 
	integer compare
	integer ssearch
	external compare
	integer i, result, ns, ne
	data a /  0, 4, 4, 4, 4, 4, 9, 8, 7, 7, 7, 7, 7, 4, 3, 2, 1 /

	call show_table ( a, n ) 
	call shellsort ( a, n, 4, compare, 0 ) 
	call show_table ( a, n ) 
10      read ( *, *, end = 20 ) i 
	write (*,*) "searching for ", i
	result = ssearch ( i, 4, a, n, 0, compare, 0, ns, ne ) 
	write (*,*) "result = ", result, "  ns=", ns, "  ne=", ne 
	goto 10
    
20      stop
	end

	integer function compare ( a, b, private ) 
	integer a, b, private
	compare =  a-b 
	end

	subroutine show_table ( a, n ) 
	integer n 
	integer a(n)
	integer i 

	do i=1,n
	    write (*,*) i, a(i)
	    end do
	
	end
moser% tryshell < trysearch.in
    .
    .
    .
   1  0
   2  1
   3  2
   4  3
   5  4
   6  4
   7  4
   8  4
   9  4
   10  4
   11  7
   12  7
   13  7
   14  7
   15  7
   16  8
   17  9
 searching for   -1
 result =   0  ns=  1  ne=  0
 searching for   0
 result =   1  ns=  1  ne=  1
 searching for   2
 result =   1  ns=  3  ne=  3
 searching for   4
 result =   6  ns=  5  ne=  10
 searching for   5
 result =   0  ns=  11  ne=  10
 searching for   7
 result =   5  ns=  11  ne=  15
 searching for   8
 result =   1  ns=  16  ne=  16
 searching for   9
 result =   1  ns=  17  ne=  17
 searching for   10
 result =   0  ns=  18  ne=  17
moser%
.fi
.SH RETURN VALUES
\fBssearch\fR returns the number of matching keys.
.SH LIBRARY
libstock.a
.SH DIAGNOSTICS
none
.SH "SEE ALSO"
.nf
shellsort(3f)
.fi
.SH "BUGS AND CAVEATS"
.SH AUTHOR
Daniel Quinlan

.\" $Id: ssearch.3f,v 1.1.1.1 1997/04/12 04:19:02 danq Exp $ 
