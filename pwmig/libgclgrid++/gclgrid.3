'\" te
.TH gclgrid 3 "$Date: 2003/01/20 14:42:01 $"
.SH NAME
gclgrid - C++ Geographical Curvilinear Coordinate grid librarY
.SH SYNOPSIS
.nf
#include "gclgrid.h"
// main objects
class GCLgrid;
class GCLgrid3d;
class GCLscalarfield:GCLgrid;
class GCLvectorfield:GCLgrid;
class GCLscalarfield3d:GCLgrid3d;
class GCLvectorfield3d:GCLgrid3d;
// helpers
double r0_ellipse(double);
double ****create_4dgrid_contiguous(int, int, int, int);
double ***create_3dgrid_contiguous(int, int, int);
double **create_2dgrid_contiguous(int, int);
void GCLlookup_error_handler(int);
.fi
.SH DESCRIPTION
.LP
A GCLgrid is defined as a 2d or 3D uniform grid 
(i.e. squares in 2D and cubes in 3D) with a one-to-one 
mapping into geographic coordinates on the earth.  
The mapped grid does not need to be uniformly spaced 
nor flat in any sense.  A GCLgrid (2d), for example, can,
and often is a spherical surface at constant radius, but 
it does not have to be.  On a spherical surface the spacing
between nodes can only approximately be constant.  Similarly
a GCLgrid3D may define a spherical shell broken into approximate
cubes or it can be some more general shape.  The primary 
restiction is that the library assumes that the mapping operator
from a standard rectangle (2D) or box (3D) does not fold space.
This is the "Curvilinear" modifier.  It means that the coordinate
axes and all grid lines form a mesh of curves that never cross 
along constant trajectories of the curvilinear axes (x1, x2, and x3).  
Two type examples are a deformed box and a box warped into a 
spherical shell.  

The library centers on two critical algorithms:  lookup and interpolate.
By lookup I mean given a point in space (on the earth) find the position
of that point within the grid.  For uniformly divided box this is a 
trivial calculation for a distorted grid the process is never simple.
The GCLgrid library uses a search method that is a form of Newton's
method. We compute vector direction for the local tangent to each 
grid line by simple forward differences.  We then project the actual 
position onto this vector direction and estimate the number of grid 
points to jump to get to the new position.  An important efficiency
element is that the interface always stored the previous index and 
will normally start from the previously computed point.  This makes it
relatively quick to search down a grid line to, for example, map one
GCLgrid onto another.  The lookup function only has to make large 
corrections when a large position shift is requested.  This is 
important to realize as the lookup time for a grid that has significant
distortion is drastically different for random access than sequential
access along curved trajectories through space.  

The interpolation methods are based on 8 point (corners of a box) 
shape functions borrowed from finite element analysis.  Note that in
this implementation this is true of both 2d and 3d grids.  These are
used in 2d because a GCLgrid is a surface embedded in 3-space.  
When the four points that define the region to be interpolated are 
not coplanar a rectangular interpolator that assumes a 2D projection
is problematic.
The interpolate method should only be called after a successful lookup.
.SH INTERFACE
.LP
Here is the full definition of the data objects that define the
GCLgrid interface.  They are defined beginning a the top of the
class heirarchy and working down.  
.ce
\fIGCLgrid\fR - Basic 2D GCLgrid object
.nf
class GCLgrid
{
	public:
		char name[10];  // name assigned to this coordinate grid
		double lat0, lon0, r0;  // geographical location of origin 
		double azimuth_y;  // Azimuth of positive y axis 
		double dx1_nom, dx2_nom;  // nominal grid spacing 
		int n1,n2;  // grid size in each component direction
		int i0, j0;  // origin location in grid 
		double x1low, x1high, x2low, x2high, x3low, x3high;// bounding box 
		bool cartesian_defined, geographic_defined;
		double **x1, **x2, **x3; //cartesian coordinates of nodes
		double **lat, **lon, **r;  //geographical coordinates of nodes

		GCLgrid(){
			n1=0;n2=0;x1=NULL;x2=NULL;x3=NULL;lat=NULL;lon=NULL;r=NULL;
		};
		GCLgrid(int n1size, int n2size);
		GCLgrid(int n1size, int n2size, char *n, double la0, double lo0,
			double radius0, double az, double dx1n, double dx2n, 
			int iorigin, int jorigin);
		GCLgrid(Dbptr db, char *nm);  // acquire from Antelope database 
		GCLgrid(const GCLgrid&);  //standard copy constructor
		GCLgrid& operator=(const GCLgrid& );
		void dbsave(Dbptr, char *);
		void lookup(double, double) throw(int);
		void reset_index() {ix1=i0; ix2=j0;};
		void get_index(int *ind) {ind[0]=ix1; ind[1]=ix2;};
		Geographic_point ctog(double, double, double);
		Cartesian_point gtoc(double, double, double);
		void GCLset_transformation_matrix();
		double depth(int,int);
		~GCLgrid();
		//
		//These derived classes need private access so are declared
		//friends
		//
		friend class GCLgrid3d;
		friend class GCLscalarfield;
		friend class GCLvectorfield;
		friend class GCLscalarfield3d;
		friend class GCLvectorfield3d;
	private:
		int ix1, ix2;
		double gtoc_rmatrix[3][3];
		double translation_vector[3];
};
.fi
.LP
The simple type parameters that define this data object are, I hope,
reasonably well defined by the comments in the above code segment.  
The key groups of defining parameters are these:
.IP (1)
lat, lon, and r are 2d grids that define a 2d surface in geographical
coordinates.
.IP (2)
x1, x2, and x3 are parallel 2d arrays that give coordinates in a 
Cartesian coordinate system.  The transformation from geographic
to the Cartesian system is defined through the member functions
gtoc(lat,lon,r) and ctog(x1,x2,x3).  These use the private variables
gtoc_rmatrix and translation_vector to do this transformation.
The Cartesian system is produced by translating spherical geometry 
coordinates to a standard Cartesian system.  That system is defined
with x1 through the intersection of the prime merdian and the equator,
x2 through the equator and +90 degrees longitude, and x3 through the
north pole.  The Cartesian system in a GCLgrid translates this 
coordinate system to an origin defined by the \fItranslation_vector[3]\fR.
This coordinate system is then rotated by the transformation matrix
defined as \fIgtoc_rmatrix\fR.  (Note that gtoc_rmatrix is orthogonal
so the inverse tranformation is simply the transpose of it.)  
The origin of the Cartesian system is visible publically as the
variables lat0, lon0, and r.  Note that internally ALL angle
variables (like lat0 and lon0) are stored in radians.  
.IP (3)
i0 and j0 define the location of the Cartesian origin inside the grid.
The azimuth_y variable is set to the azimuth of the x2 axis at this
origin.  For example, if azimuth_y is 10 degrees (note internally this
is radians) the x2 axis at the origin will point 10 degrees east of
north.  For some grids azimuth_y has no purpose but for a standard
grid produced by the parameterized constructor (see below) it 
uniquely defines the grid orientation.  
.IP (4)
n1 and n2 define the size of the 2d arrays used to define the grids of
points.  
.IP (5) 
dx1_nom and dx2_nom are the nominal grid spacing intervals for the
x1 and x2 axes.  Units are always kilometers.
.IP (6)
x1low, x1high, x2low, x2high, x3low, and x3high define a bounding box
in the Cartesian system for all the points in the grid.  This provides
a simple sanity check and a fast way to discard any request for points
well outside the area the grid defines.  
.IP (7)
The two booleans, cartesian_defined and geographic_defined, 
are set true when the contents of the cartesian and geographic 
arrays are valid.  They will be set false if if the contents of
these arrays are not defined.  
.LP
\fIConstructors\R.  
Notice that the GCLgrid has several levels of constructors.  
The one with no parameters simply creates the basic structure using
system generated constructors and sets the 2d array points all NULL.  
It also initializes all regular variables to 0.
GCLgrid(int n1size, int n2size) is similar but it allocates
memory for the 2d coordinate arrays.  (See Memory Management section
below)
The only complete constructor is this one:
.nf
GCLgrid(int n1size, int n2size, char *n, double la0, double lo0,
	double radius0, double az, double dx1n, double dx2n, 
	int iorigin, int jorigin);
.fi
The parallel to the defining parameters should be clear.  
This constructor builds what we might call a "standard GCLgrid".
This objct is produced by this sequence of steps:
.IP a)
At the Cartesian origin
project an x1 axis at the azimuth of azimuth_y+PI_2 
(i.e. 90 degrees clockwise from what will become the x2 axis)
along a great circle path.  Divide this path into 
n1size segments of size dx1n.  The origin is set at 
grid point iorigin (Note C indexing convention.  This 
is the index position in the grid for the origin point. 
There is no -1 correction to get it.)  
.IP b)
Get the pole to this great circle (in direction azimuth_y)
and draw a great circle along that trajectory.  Divide this
curve into segments of size dx2n.  The origin is set at 
grid point jorigin.
.IP c)
The constant x1 trajectory lines are drawn like longitude 
lines to the pole that defines x2 and the equator defined by
the x1 axis passing through the origin.  The constant x2 trajectory
lines are then latitude-like paths (i.e. they are not great circles).  
.ce
\fIGCLgrid3d\R - 3D GCLgrid object
.nf
.LP
The 3d version of a GCLgrid is similar to the 2d version.  In fact,
it acquires most of it's members by inheritance.  Here is the 
full description:
.nf
class GCLgrid3d : public GCLgrid
{
	public:
		double dx3_nom;
		int n3;
		int k0;
		double ***x1, ***x2, ***x3;
		double ***lat, ***lon, ***r;

		GCLgrid3d(){
			n1=0;n2=0;n3=0;
			x1=NULL;x2=NULL;x3=NULL;lat=NULL;lon=NULL;r=NULL;
		};
		GCLgrid3d(int n1size, int n2size, int n3size);
		GCLgrid3d(int n1size, int n2size, int n3size, 
			char *n, double la0, double lo0,
			double radius0, double az, 
			double dx1n, double dx2n, double dx3n,
			int iorigin, int jorigin);
		GCLgrid3d(Dbptr db, char *nm); 
		GCLgrid3d(const GCLgrid3d&); 
		GCLgrid3d& operator=(const GCLgrid3d& );
		void dbsave(Dbptr, char *);
		void lookup(double, double, double) throw (int);
		void reset_index() {ix1=i0; ix2=j0; ix3=k0;};
		void get_index(int *ind) {ind[0]=ix1; ind[1]=ix2; ind[2]=ix3;};
		double depth(int,int,int);
		~GCLgrid3d();
	private:
		int ix1, ix2, ix3;
};	  		
.fi
.LP
Everything is highly parallel except 2d things become 3d.  This
requires adding:  nx3 = size of objects in the third dimension; 
dx3_nom = nominal grid size in x3 direction; and k0 = location of
the origin in the 3rd dimension.
The member functions require a third parameter when required.

//
//These are generic scalar and vector fields defined on a GCLgrid object
//of 2 or 3d
//
class GCLscalarfield :  public GCLgrid
{
	public:
		double **val;

		GCLscalarfield();
		GCLscalarfield(int, int);
		GCLscalarfield(GCLgrid& );
		GCLscalarfield& operator=(const GCLscalarfield&);
		void operator+=(const GCLscalarfield&);
		void operator*=(double);
		double interpolate(double,double,double);
		~GCLscalarfield();
};
class GCLvectorfield : public GCLgrid
{
	public:
		int nv;
		double ***val;

		GCLvectorfield();
		GCLvectorfield(int,int,int);
		GCLvectorfield(GCLgrid &,int);
		GCLvectorfield& operator=(const GCLvectorfield&);
		void operator+=(const GCLvectorfield&);
		void operator*=(double);
		double *interpolate(double,double,double);
		~GCLvectorfield();
};
class GCLscalarfield3d : public GCLgrid3d 
{
	public:
		double ***val;

		GCLscalarfield3d();
		GCLscalarfield3d(int,int,int);
		GCLscalarfield3d(GCLgrid3d &);
		GCLscalarfield3d& operator=(const GCLscalarfield3d&);
		void operator+=(const GCLscalarfield3d&);
		void operator*=(double);
		double interpolate(double,double,double);
		~GCLscalarfield3d();
};
class GCLvectorfield3d : public GCLgrid3d
{
	public:
		int nv;
		double ****val;

		GCLvectorfield3d();
		GCLvectorfield3d(int,int,int,int);
		GCLvectorfield3d(GCLgrid3d &,int);
		GCLvectorfield3d& operator=(const GCLvectorfield3d&);
		void operator+=(const GCLvectorfield3d&);
		void operator*=(double);
		double *interpolate(double,double,double);
		~GCLvectorfield3d();
};
.nf
.fi
.in
.ft R
.SH MEMORY MANAGEMENT
.LP
Be aware that these functions can consume large quantities of memory
very quickly.  GCLvectorfield3d, for example, requires allocation of
a 4D array which can quickly get huge even for fairly small dimensions.  
The user should also note that all the constructors used here for
building these arrays are in plain C and build these arrays from
contiguous blocks of memory.  That is, C implements subscripted
arrays through arrays of pointers.  To avoid what could easily
be millions of new (malloc) memory requests the arrays are built
by constructing pointers into contiguous blocks of memory.  
This is hidden in the interface for normal use.  If, however, you
try to construct one of these objects manually from the
unparameterized constructors you are nearly guaranteed to encounter
problems when the destructor is called on the object.  You might
get by with this if the destructor is called only on program exit, but
otherwise its the old Clint Eastwood line:  "Do you feel lucky, punk?".
In short, if you have to build one of these objects manually, you 
should use the size parameterized constructors (e.g. GCLGrid(int n1, int n2))
and then fill in the contents.  
.SH ERROR CONDITION
.LP
The db (dbsave and the constructor with the Dbptr argument) functions 
throw an exception if problems are encounted.  Consequently, calls to 
these functions need to be enclosed in the C++ try/catch construct 
with an int error handler.  
All thrown errors by these functions are serious and should probably
normally cause the program to die with a diagnostic.
Actually, all these functions post an elog (elog(3)) message before
throwing an error.
The return codes that need to be caught are:
.IP 1
This indicates a database related error of some kind.  
An extension table that defines a GCLgrid object 
(gclgrid table) needs to be defined and correct attributes names need to be
defined or this error will be returned.  I can also come from 
multiple possible db problems.
The elog will contain details that should help define the problem.
.IP  2
I/O error problems.  These functions read a GCLgrid or GCLgrid3d object stored
on disk.  Any read problems will throw this code.
.SH RETURN VALUES
.LP
The \fBlookup\fB functions are implemented in the C fashion of returning
an error code rather than the C++ approach of throwing exceptions.  
This was intentional because Sun's documentation points out that
throwing exceptions is "computationally expensive" compared to this 
approach.  Further, lookup has a classic problem with complex algorithms
that have ways they can fail:  some failures are serious problems that
should cause the program to abort while others are not really errors
but a condition the algorithm can't handle.  These are distinguished
in lookup's error returns by sign.  A positive return means a problem
that should be handled, but which should be considered common and normal.
Negative returns are a serious error that should be handled differently.
The actual codes are:
.IP 2
A warning about a point in the grey area at the edge of the grid.  
It means interpolation is possible, but is potentially subject to
fairly large errors because we have to extrapolate instead of
interpolate.  This is returned only when the distance of the requested
point is within one unit cell of the grid in all directions.
Unless the function being interpolated is extremely rapidly varying
the results in this case are probably ok.
.IP 1
The requested point is outside the bounds of this grid.  Index 
position is undefined.  This condition should be caught as a nonfatal
error as it should be common to ask for a point outside a defining
box.  This will also be returned if the point is inside the bounding
box but more than one nominal cell length from the edge.
.IP -1
Convergence error.  The user should assume the point returned in
the index is meaningless and handle the error appropriately.
.IP -2
One or more parts of the GCLgrid arrays are incomplete.  This should
only happen if one creates a GCLgrid manually using an incomplete
constructor.  
The calling program should trap this condition and terminate the program
as a coding error.  

.SH LIBRARY
$(DBLIBS) -lgclgrid
.SH "BUGS AND CAVEATS"
This library is the author's first serious attempt at a C++
package.  Some things may be done in an odd way as a result and
the results should be viewed with a healthy dose of skepticism.
Some specifics are:
.IP (1)
Although in theory the interface should allow a space reduction by 
defining only the geographic or cartesian arrays I've used the 
memory hog model here.  That is, one really need only store the
Cartesian coordinates and use the ctog function compute latitude
and longitudes.  I've used the parallel array (at a huge memory
cost) approach expecting the need to have both sets of coordinates
be a very common operation.  If memory becomes an issue an extension 
of the library could do this without changing the interface.

.SH AUTHOR
.nf
Gary L. Pavlis and Chengliang Fan
Indiana University
pavlis@indiana.edu
.fi
.\" $Id: gclgrid.3,v 1.2 2003/01/20 14:42:01 pavlis Exp $
