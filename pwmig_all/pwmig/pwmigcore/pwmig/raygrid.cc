#include "gclgrid.h"
#include "dmatrix.h"
#include "seispp.h"
#include "ray1d.h"
using namespace std;
using namespace SEISPP;
#include "pwmig.h"
/* Used below to copy a dmatrix defining a ray path into the ith, jth 
grid line (vertical-like ) of the GCCgrid3d object raygrid.  
It does check to verify that dimensions are consistent.
If the path is longer or exactly matches the grid dimension
this function returns 0.  If the path is short the raygrid is
generated by projecting along a straight line from the last valid
point in path (last meaning the deepest).  The function returns
a -1 if the input path is invalid and impossible to work with.
This means simply that the path matrix does not have at least 
2 data points (the minimum needed for a straight line projection).
This was intentionally not done through an exception mechanism
as the books all say exceptions slow function calls.  Since this
is a fairly low level routine limited in scope to this file this
is a preferred mechanism.  For the purest, get a life.

A major complicating factor here is that a GCLgrid insists that
the gridlines run in an upward sequence to maintain a right handed
coordinate system in finite element style boxes.  This means the
path needs to be inverted (first column of path is placed at 
the n3-1 position in the raygrid).  
*/
int copy_path(dmatrix& ray,RayPathSphere& rps, GCLscalarfield3d& raygrid,int i, int j)
{
	int k,kk;
	int status;
	int path_length=ray.columns();
	if(path_length<2) return(-1);
	if(path_length>=raygrid.n3)
	{
		for(k=0,kk=raygrid.n3-1;k<raygrid.n3;++k,--kk)
		{
                    /* This copies the 1D travel time field to ray path val position.
                     * Note this accumulates time from the surface downward.   */
			if(k>=path_length) break;
			raygrid.x1[i][j][kk]=ray(0,k);
			raygrid.x2[i][j][kk]=ray(1,k);
			raygrid.x3[i][j][kk]=ray(2,k);
                        raygrid.val[i][j][kk]=rps.t[k];
		}
		status=0;
	}
	else
	{
		// this block handles short input path with
		// a linear projection from the deepest point.
		// Done by creating a new temporary dmatrix 
		// with the extended path and running the 
		// same algorithm as above.
		double dx1,dx2,dx3;
		dx1=ray(0,path_length-1)-ray(0,path_length-2);
		dx2=ray(1,path_length-1)-ray(1,path_length-2);
		dx3=ray(2,path_length-1)-ray(2,path_length-2);
                // Extend travel time vector by increment in last path pair
                double delta_time=rps.t[path_length-1]
                                    - rps.t[path_length-2];
		dmatrix extendedray(3,raygrid.n3);
		for(k=0;k<path_length;++k)
			for(int l=0;l<3;++l)
				extendedray(l,k)=ray(l,k);
		for(k=path_length;k<raygrid.n3;++k)
		{
			extendedray(0,k)=extendedray(0,k-1)+dx1;
			extendedray(1,k)=extendedray(1,k-1)+dx2;
			extendedray(2,k)=extendedray(2,k-1)+dx3;
		}
		for(k=0,kk=raygrid.n3-1,status=0;k<raygrid.n3;++k,--kk)
		{
			raygrid.x1[i][j][kk]=extendedray(0,k);
			raygrid.x2[i][j][kk]=extendedray(1,k);
			raygrid.x3[i][j][kk]=extendedray(2,k);
                        if(k<path_length)
                            raygrid.val[i][j][kk]=rps.t[k];
                        else
                        {
                            raygrid.val[i][j][kk]
                                =raygrid.val[i][j][kk+1]+delta_time;
                            ++status;
                        }
		}
	}
        /* Return the number of extension points */
	return(status);
}
/* Brutal procedure found to be necessary to deal with turning rays in the P 
 * raygrid for incident waves and likely also for some S grids.  This trims
 * the raygrid from raygrid.n3 to n3trimlen.   This assumes the major
 * complication that the points need to be stripped from the bottom which is
 * the 0 to raygrid.n3-n3trimlen points. */
GCLscalarfield3d *trim_raygrid_n3(GCLscalarfield3d& raygrid, int n3trimlen)
{
    GCLscalarfield3d *tptr = new GCLscalarfield3d(raygrid.n1, raygrid.n2, n3trimlen);
    tptr->lat0=raygrid.lat0;
    tptr->lon0=raygrid.lon0;
    tptr->r0=raygrid.r0;
    tptr->azimuth_y=raygrid.azimuth_y;
    tptr->dx1_nom=raygrid.dx1_nom;
    tptr->dx2_nom=raygrid.dx2_nom;
    tptr->dx3_nom=raygrid.dx3_nom;
    tptr->n1=raygrid.n1;
    tptr->n2=raygrid.n2;
    tptr->i0=raygrid.i0;
    tptr->j0=raygrid.j0;
    tptr->name=raygrid.name;
    tptr->name=raygrid.name;
    tptr->k0=n3trimlen-1;  // earth surface in new grid
    tptr->set_transformation_matrix();
    int i,j,k,kk;
    for(i=0;i<raygrid.n1;++i)
        for(j=0;j<raygrid.n2;++j)
            /* k is index for raygrid and kk for trimmed grid */
            for(k=raygrid.n3-1,kk=n3trimlen-1;kk>=0;--k,--kk)
            {
                tptr->x1[i][j][kk]=raygrid.x1[i][j][k];
                tptr->x2[i][j][kk]=raygrid.x2[i][j][k];
                tptr->x3[i][j][kk]=raygrid.x3[i][j][k];
                tptr->val[i][j][kk]=raygrid.val[i][j][k];
            }
    return tptr;
    // WARNING - memory leak prone here
}



/* This function acts like a constructor, but it isn't made an explicit part of the object
definition because it is a special construction used for this program.  

Arguments:
	fixed_u_mode - boolean.  If true, use one ray for all points.
		if false, trace a new ray for each grid point.  Former is 
		faster, but a poor approximation for large arrays and
		relatively close sources.
	parent - 2d surface GCLgrid of pseudostation grid points 
	u - slowness vector used to generate this ray grid (note for large grids this points in
		different directions at different points even though the vector is fixed)
		(Note used even when fixed_u_mode is false to establish
		grid dimensions )
        svm - congruent matrix of slowness vectors used when fixed_u_mode
            is set false.  Ignored when that variable is true.
	vmod - 1d velocity model used for ray tracing 
	zmax, tmax - depth, time maxima used to define ray trace limits.

Note that the number of points that define each ray path is set by the ray tracing.  The
same ray, in fact, is used for all elements but the projection is spatially dependent because
of earth curvature and geographical coordinate conventions on how slowness vector are 
traditionally defined.  This algorithm is a bit at odds with the gclgrid model where the
object is to reduce artifacts for where on earth the grid happened to be positioned.  This 
approach may cause problems for grids near the pole and will definitely not work for a grid
that spans the pole.  Since neither is likely in the near future this seems a minor 
concession to simplicity.  

The number of points in n3 direction is determined by the ray tracing and is implicitly 
returned as the n3 variable in the newly created GCLgrid3d object.  Note carefully that
this function acts like new and the object must eventually be deleted explicitly.  

It is also VERY important to recognize this constructor produces ray grids that 
are oriented from the bottom up.  This is useful to keep the set of basis vectors
at all points right handed.  

History:
Original published in the 2011 Computers and Geosciences paper used a
Hypocenter object and then computed slowness vectors to define 1d
ray tracing.   Changed Jan 2015 to use a new concept of a 
SlownessVectorMatrix passed with the data.  This eliminated the need
to deal with the obnoxious taup calculator code in dsap, which proved
virtually impossible to adapt, and provide a clean mechanism to allow
variable slowness vectors for scattered wave components.  The previous
version had to use fixed slowness vector mode which I suspect produced
artifacts in USArray data as it grew to full scale.   Arg 4 in the 
previous version was a Hypocenter object.  Now it is a the
SlownessVectorMatrix. 

Note the dimensions of the SlownessVectorMatrix and GCLgrid object
are not tested for consistency.  Because this is used internally only
in pwmig we avoid the overhead of error handlers for efficiency.

Further change Feb 2015
Modified assuming 3D model was travel time perturbations.  This was
a major change.  The pervious version returned a GCLgrid3d object.
This returns a GCLscalarfield3d object with 1D travel times loaded
in the field variables.  

Author:  Gary Pavlis
*/  


GCLscalarfield3d *Build_GCLraygrid(bool fixed_u_mode,
		GCLgrid& parent,
		SlownessVector u, SlownessVectorMatrix& svm,
		VelocityModel_1d& vmod,
		double zmax, double tmax, double dt)
{
	int i,j;
	double umag, theta;  // used many times so we make temporaries of these
	if(fixed_u_mode)
	{
		umag = u.mag();
		theta = u.baz();
	}
	// First trace the basic ray object that will be projected.  This gets dimensions.
	RayPathSphere base_ray(vmod, u.mag(), zmax, tmax, dt, "t");

	// call the simple, parameterized GCLgrid constructor that allocs space but has no content
	GCLscalarfield3d *rgptr = new GCLscalarfield3d(parent.n1, parent.n2, base_ray.npts);
	GCLscalarfield3d& raygrid = *rgptr;
	// clone these parent grid variable
	raygrid.name=parent.name;
	raygrid.lat0=parent.lat0;
	raygrid.lon0=parent.lon0;
	raygrid.r0=parent.r0;
	raygrid.azimuth_y=parent.azimuth_y;
	raygrid.dx1_nom=parent.dx1_nom;
	raygrid.dx2_nom=parent.dx2_nom;
	raygrid.n1=parent.n1;
	raygrid.n2=parent.n2;
	raygrid.i0=parent.i0;
	raygrid.j0=parent.j0;
	/*  k0 must be set to the point at the earth's surface.  This is necesary
	to set the transformation at this point to keep all grids consistent. 
	The ray bottom will depend on the slowness vector */
	raygrid.k0 = base_ray.npts - 1;  // earth's surface or this will be
					// inconsistent with lat0,lon0
	// need to explicitly set the transformation matrix like this 
	// as it can only be set through this mechanism
	raygrid.set_transformation_matrix();
	//
	// now start filling up the field with the cartesian points and travel times
	//
	dmatrix *path;
        RayPathSphere ray(base_ray);
        int trimlength=raygrid.n3;
	for(i=0;i<parent.n1;++i)
		for(j=0;j<parent.n2;++j)
		{
			int nextended;
                        int tlenthis;
			try {
			    if(fixed_u_mode)
			    {
				path = GCLgrid_Ray_project(parent,base_ray, 
					theta, i,j);
			    }
			    else
			    {
                                SlownessVector uij=svm(i,j);
				umag=uij.mag();
				theta=uij.baz();
				ray=RayPathSphere(vmod, uij.mag(), zmax, tmax, dt, "t");
				path = GCLgrid_Ray_project(parent,ray, 
					theta, i,j);

			    }
                            /* A very confusing thing here is that through
                             * evolution of this program the easiest way to
                             * add the travel time to the field is in this
                             * procedure.   That is travel times from ray
                             * are copied into the raygrid val array by
                             * this procedure. */
			    nextended=copy_path(*path,ray,raygrid,i,j);
			    delete path;
			    if(nextended<0) 
			    {
				cerr << "copy_path:  length error"<<endl
					<< "Passed a path of length "
					<< path->columns()<<endl
					<< "Cannot continue"<<endl;
				exit(-1);
			    }
                            else if(nextended>0)
                            {
                                tlenthis=raygrid.n3-nextended;
                                if(tlenthis<trimlength) trimlength=tlenthis;
                                
                            }

			}
			catch (GCLgrid_error& err)
			{
				err.log_error();
				cerr << "Cannot continue" <<endl;
				exit(-1);
			}
		}
        if(trimlength<raygrid.n3)
        {
            cout << "Warning:  Triming incident P wave grid from "
                <<raygrid.n3<<" points on ray path to "<<trimlength<<endl
                << "Created by turning rays for P.  Consider reducing tmax or zmax parameters"
                <<endl;
            GCLscalarfield3d *trgptr;
            /*Note raygrid and rgptr are the same object */
            trgptr=trim_raygrid_n3(raygrid,trimlength);
            delete rgptr;
            rgptr=trgptr;
        }

	// Before we return we have to recompute the grid extents.
	rgptr->compute_extents();

	return(rgptr);

}
