.\" %%W%% %$Date: 1997/07/21 00:41:27 $%


.TH BITVECTOR 3 "$Date: 1997/07/21 00:41:27 $"
.SH NAME
newbit, bitfree, bitset, bitclr, bittst, bitand, bitor, bitxor, bitnot \- operations on bit vectors
.SH SYNOPSIS
.nf
Bitvector *newbit() ;
void	freebit(Bitvector *b) ;

int bitset ( Bitvector *b, int index );
int bitclr ( Bitvector *b, int index );
int bittst ( Bitvector *b, int index );
int bitmax ( Bitvector *b) ;

Bitvector *bitand ( Bitvector *b1, Bitvector *b2 );
Bitvector *bitor  ( Bitvector *b1, Bitvector *b2 );
Bitvector *bitxor ( Bitvector *b1, Bitvector *b2 );
Bitvector *bitnot ( Bitvector *b );

.fi
.SH DESCRIPTION
These routines implement variably sized bit-vectors, which are
useful in various logical set operations.
They are actually implemented as lists (see tbl(3)).
.LP
The routines are mostly self-explanatory.  Bitset sets a bit, 
bitclr clears a bit, bittst tests a bit.  Bitset and bitclr
return the previous value of the selected bit.
.LP
bitmax returns the size in bits of the current vector.  This
is not the same as the maximum bit set in the vector, and will
(currently) always return a multiple of 32.
.LP
bitand takes two bit vectors, and returns the bitwise and.
bitor takes two bit vectors, and returns the bitwise or.
bitxor takes two bit vectors, and returns the bitwise exclusive or.
bitnot takes a bit vector and returns its bitwise not.
.SH LIBRARY
-lstock
.SH EXAMPLE
.nf

    #include <stdio.h>

    #include "stock.h"

    static void
    usage ()
    {
	fprintf (stderr, "Usage: %s -n #bits\n", Program_Name);
	banner (Program_Name, "Version $Revision: 1.2 $ $Date: 1997/07/21 00:41:27 $\n");
	exit (1);
    }

    void 
    showtbl (char *s, Tbl *t)
    {
	int i, n ; 
	n=maxtbl(t) ;
	printf ( "\n%s\n", s ) ; 
	for (i=0 ; i<n ; i++ ) 
	    printf ( " %08x", (int) gettbl(t,i)) ;
	printf ( "\n" ) ;
    }

    int
    main (argc, argv)
    int             argc;
    char          **argv;
    {

	extern char    *optarg;
	extern int      optind;
	int             c,
			i, n = 100,
			errflg = 0;

	Bitvector	    *b1, *b2, *band, *bor, *bxor, *bnot ;
	int		    bmax ;

	Program_Name = argv[0];

	while ((c = getopt (argc, argv, "n:V")) != -1)
	    switch (c) {
	    case 'n':
		n = atoi(optarg) ; 
		break ;

	    case 'V':
		usage ();
		break;
	    case '?':
		errflg++;
	    }
	if (errflg)
	    usage ();

	printf ( "Bits per integer on this machine are %d\n", 
	    BITS_PER_INT ) ; 

	b1 = bitnew() ;
	b2 = bitnew() ;

	for (i=0 ; i<n ; i++ ) {
	    if ( i % 2 ) {
		if (bitset(b1, i))
		    complain ( 0, "bit #%d already set in b1\n", i  ) ;
	    } else {
		if (bitset(b2, i))
		    complain ( 0, "bit #%d already set in b2\n", i  ) ;
	    }
	}

	for (i=0 ; i<n ; i++ ) {
	    if ( i % 2 ) {
		if (! bittst(b1, i))
		    complain ( 0, "bit #%d not set in b1\n", i  ) ;
		if ( bittst(b2, i))
		    complain ( 0, "bit #%d set in b2\n", i  ) ;
	    } else {
		if ( bittst(b1, i))
		    complain ( 0, "bit #%d set in b1\n", i  ) ;
		if (! bittst(b2, i))
		    complain ( 0, "bit #%d not set in b2\n", i  ) ;
	    }
	}

	band = bitand (b1, b2) ; 
	bor = bitor (b1, b2) ; 
	bxor = bitxor(b1,b2) ; 
	bnot = bitnot(bxor) ;

	showtbl("b1", b1) ;
	showtbl("b2", b2) ;
	showtbl("band", band) ;
	showtbl("bor", bor) ;
	showtbl("bxor", bxor) ;
	showtbl("bnot", bnot) ;

	bmax = bitmax(b1) ;

	if ( bitmax(b2) != bmax ) 
	    complain ( 0, "b2 is %d bits long, not %d bits\n", 
		bitmax(b2), bmax ) ; 

	if ( bitmax(band) != bmax ) 
	    complain ( 0, "band is %d bits long, not %d bits\n", 
		bitmax(band), bmax ) ; 

	if ( bitmax(bor) != bmax ) 
	    complain ( 0, "bor is %d bits long, not %d bits\n", 
		bitmax(bor), bmax ) ; 

	if ( bitmax(bxor) != bmax ) 
	    complain ( 0, "bxor is %d bits long, not %d bits\n", 
		bitmax(bxor), bmax ) ; 

	if ( bitmax(bnot) != bmax ) 
	    complain ( 0, "bnot is %d bits long, not %d bits\n", 
		bitmax(bnot), bmax ) ; 

	for (i=0 ; i<n ; i++ ) {
	    if ( bittst(band, i) )
		complain ( 0, "band bit #%d is set\n", i ) ;
	    if ( ! bittst(bor, i) )
		complain ( 0, "bor bit #%d is not set\n", i ) ;
	    if ( ! bittst(bxor, i) )
		complain ( 0, "bxor bit #%d is not set\n", i ) ;
	    if ( bittst(bnot, i) )
		complain ( 0, "bnot bit #%d is set\n", i ) ;
	}

	for (i=0 ; i<n ; i++ ) {
	    if ( i % 2 ) {
		if ( ! bitclr(b1, i) )
		    complain ( 0, "bit #%d in b1 was not set.\n", i ) ; 
	    } else {
		if ( bitclr(b1, i) )
		    complain ( 0, "bit #%d in b1 was set.\n", i ) ; 
	    }
	}

	for (i=0 ; i<n ; i++ ) {
	    if ( bittst(b1, i) )
		complain ( 0, "b1 bit #%d is set\n", i ) ;
	}

	bitfree(b1) ;
	bitfree(b2) ;
	bitfree(band) ;
	bitfree(bor) ;
	bitfree(bxor) ;
	bitfree(bnot) ;

	return 0;
    }

.fi
.SH RETURN VALUES
.SH LIBRARY
-lstock
.SH DIAGNOSTICS
none
.SH "SEE ALSO"
.nf
tbl(3)
arr(3)
.fi
.SH "BUGS AND CAVEATS"
These routines do not keep track of the highest bit ever set/unset.
.SH AUTHOR
Daniel Quinlan

.\" $Id: bits.3,v 1.2 1997/07/21 00:41:27 danq Exp $ 
