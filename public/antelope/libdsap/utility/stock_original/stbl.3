.\" $Name $Revision: 1.1.1.1 $ $Date: 1997/04/12 04:19:02 $


.TH ARRAYS 3 "$Date: 1997/04/12 04:19:02 $"
.SH NAME
newstbl, addstbl, delstbl, tststbl, getstbl, maxstbl, applystbl, freestbl \- manipulate sorted lists
.SH SYNOPSIS
.nf
#include "arrays.h"

Stbl *newstbl (compare) 
int (*compare) () ; 

int setstbl (  stbl, index, key ) 
Stbl *stbl ; 
int index ; 
char *key ; 

char *addstbl ( stbl, key ) 
Stbl *stbl ; 
char *key ; 

void delstbl ( stbl, key ) 
Stbl *stbl ; 
char *key ; 

char *tststbl ( stbl, key ) 
Stbl *stbl ; 
char *key ; 

char *getstbl ( stbl, index ) 
Stbl *stbl ; 
int index ; 

int maxstbl ( stbl ) 
Stbl *stbl ; 

int freestbl ( stbl, free_stbl_val ) 
Stbl *stbl ; 
int (*free_stbl_val) () ; 

int applystbl ( stbl, function, private ) 
Stbl *stbl ; 
int (*function) () ; 
void *private ; 

.fi
.SH DESCRIPTION
These routines implement a combination of associative 
arrays (see arr(3)) and lists (see tbl(3)).
These sorted lists allow keeping a sorted data structure
of indeterminate size which may be indexed like a list.
The underlying structure, however, is a binary tree.
This tree grows as necessary to accommodate the pointers added to it.
\fIThe tree only contains \fBunique\fI keys.\fR
.LP
These sorted lists are declared with
"Stbl *", and initialized with \fBnewstbl()\fR.  The compare argument
to \fBnewstbl\fR is a function which returns an integer indicating
the relationship between two keys (pointers) of the table.  The default
(if this argument is NULL) is strcmp; use its declaration as an example
of how to write your own compare routine.
.LP
Elements are added using \fBaddstbl\fR, and deleted with \fBdelstbl\fR.
\fBAddstbl\fR returns the pointer to the added element; if an element
which matches the passed key already exists, a pointer to that element
is returned.
.LP
You may test if an element exists with the routine tststbl; it returns
a pointer to the element if it's found, otherwise zero.
.LP
The number of elements in a table may be found with
\fBmaxstbl\fR.  
An element of the table is returned by \fBgetstbl\fR. 
.LP
Note that the table holds only pointers; the actual data must be
kept by the user in static memory -- ie, not in stack variables, or in
variables which are constantly overwritten.
.LP
Sorted tables are implemented as sorted binary trees which are condensed into
tables whenever getstbl or maxstbl is called (and the tree has changed 
since the last call).  Since this condensation is
relatively expensive, you will normally want to minimize the number of
interleaved calls to addstbl or delstbl and maxstbl or getstbl.  The typical
use envisioned for these routines is to first create a sorted table
by repeated calls to addstbl, and then to apply some function to 
every pointer in the table in order.
.LP
A function may be applied to every element of the table with the 
routine \fBapplystbl\fR.  The function which is to be applied must
take two arguments: the element, and a private pointer which would contain
any other parameters the function might need.  The function should return
an int.  The value returned by \fBapplystbl\fR is the sum of the
return values for all the calls to function.
.LP
The memory used by a table is freed with \fBfreestbl\fR; this requires
a function which is to be used to free the elements of the table.
This function takes one argument, a pointer to the element to be freed, and
returns an integer.  \fBFreestbl\fR returns the sum of all the calls
to this function.
.SH EXAMPLE
.nf
#include <stdio.h>
#include <string.h>
#include "stock.h"

typedef struct Entry { 
	int n ; 
	char *s ; 
	} Entry ;

static int printval ( value, private ) 
Entry *value ; 
char *private ; 
{ 
    printf ( private, value->s ) ; 
}

void free_entry ( e ) 
Entry *e ; 
{
    free (e->s) ;
    free ( e ) ; 
}

static int cmp ( a, b ) 
Entry *a, *b ; 
{
    return a->n - b->n ; 
}


main () 
{
    int i, n ; 
    Entry *e, *ep ;
    Stbl *stbl ;
    char aline [ 80 ] ; 
    char *private = " '%s' " ; 

    stbl = newstbl (cmp) ; 

    i = 0 ; 
    while ( gets (aline) ) { 
	i++ ;
	allot ( Entry *, e, 1 ) ; 
	e->n = strlen (aline ) ; 
	e->s = strdup ( aline ) ; 
	applystbl ( stbl, printval, private ) ; 
	printf ( "\n" ) ; 
	if ( (ep = (Entry *) addstbl ( stbl, e )) != e )  
	    {
	    complain (0, "Duplicate entry %d (%s)\n", e->n, e->s ) ; ; 
	    free_entry ( e ) ; 
	    }
	}
    
    n = maxstbl ( stbl ) ; 
    printf ( "stbl has %d values -- %d entered.\n", n, i ) ; 
    for ( i = 0 ; i< n ; i++ ) 
	{
	ep = (Entry * ) getstbl ( stbl, i ) ; 
	printf ( "stbl[%d] = %d (%s)\n", i, ep->n, ep->s ) ; 
	}

    printf ( "\nResults of applystbl: \n" ) ; 
    applystbl ( stbl, printval, private ) ; 

    printf ( "\n" ) ; 

    printf ( "Finally, try freeing the space.\n" ) ; 
    freestbl ( stbl, free_entry ) ; 
    return 0 ;
}

.fi
.SH RETURN VALUES
There are no error conditions for these routines, except running out of
memory, in which case the program will die.  An attempt to access a
non-existent array value will return null.
.SH LIBRARY
-lstock
.SH DIAGNOSTICS
none
.SH "SEE ALSO"
.nf
tbl(3)
arr(3)
strcmp(3)  
.fi
.SH "BUGS AND CAVEATS"
.SH AUTHOR
Daniel Quinlan

.\" $Id: stbl.3,v 1.1.1.1 1997/04/12 04:19:02 danq Exp $ 
