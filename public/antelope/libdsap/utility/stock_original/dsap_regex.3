.\" $Name $Revision: 1.1 $ $Date: 1997/07/21 00:41:27 $
.TH REGEX 3 "$Date: 1997/07/21 00:41:27 $"
.SH NAME
re_compile_pattern, re_match, re_search, re_free \- regular expression searching and matching
.SH SYNOPSIS
.nf
#include "dsap_regex.h"

const char * re_compile_pattern ( const char *pattern, 
	int length, struct re_pattern_buffer *bufp );

int re_search ( struct re_pattern_buffer *bufp, const char *string, 
	int size, int startpos, int range, struct re_registers *regs );

int re_match ( struct re_pattern_buffer *bufp, const char *string, 
	int size, int pos, struct re_registers *regs );

void re_free (struct re_pattern_buffer *bufp);

.fi
.SH DESCRIPTION
These routines use a modified version of Henry Spencer's implementation
of regexp(3) regular expression routines.
.LP
Regular expressions must first be compiled with \fBre_compile_pattern\fR, 
and then evaluated with either \fBre_search\fR (to search a string for
a matching pattern, ie an index function), or \fBre_match\fR (to see
if a string matches the pattern).  \fBRe_search\fR returns the index
of the matching pattern; \fBre_match\fR returns the number of characters
starting from character 0 which match the pattern.
.LP
Before calling re_compile_pattern, you \fBmust\fR initialize the pattern
buffer as shown in the example below.
.LP
After you're done, you can free the buffers which re_compile_pattern
allocates with re_free.  
.SH OPTIONS
.SH EXAMPLE
.nf
#include <stdlib.h>
#include <stdio.h>
#include "dsap_regex.h"
#include "stock.h"
 
main (argc, argv ) 
int argc ; 
char *argv ; 
{
    char pattern[STRSZ], string[STRSZ], *s ; 
    int result ;
    struct re_registers *regs = 0 ; 
    struct re_pattern_buffer *pattern_buffer = 0 ; 
 
    re_syntax_options = RE_SYNTAX_EGREP ;  
 
    allot ( struct re_pattern_buffer *, pattern_buffer, 1 ) ; 
    pattern_buffer->buffer = 0 ; 
    pattern_buffer->allocated = 0 ; 
    pattern_buffer->translate = 0 ; 
    pattern_buffer->fastmap = 0 ;  
 
    printf ( "Pattern: " ) ; 
    for  ( s = gets(pattern)  ; s != 0 && *s != 0 ; s = gets(pattern) ) 
        {
        if (  (s = re_compile_pattern ( pattern, 
                    strlen(pattern), pattern_buffer ) ) != 0 ) 
            complain ( 0, "Pattern did not compile: %s.\en", s ) ;
        else
            {
            printf ( "String: " ) ; 
            for  ( s = gets(string)  ; s != 0 && *s != 0 ; s = gets(string) ) 
                {
                result = re_match ( pattern_buffer, 
                        string, 
                        strlen(string), 
                        0, 
                        regs ) ; 
                printf ( "Match result is %d\en", result ) ;  
 
                result = re_search ( pattern_buffer, 
                        string, 
                        strlen(string), 
                        0, 
                        strlen(string),
                        regs ) ; 
                printf ( "Search result is %d\en", result ) ;  
 
                printf ( "String: " ) ; 
                }
            }
        printf ( "Pattern: " ) ; 
        }
    re_free ( pattern_buffer ) ; 
    return 0 ; 
}
.fi
.SH RETURN VALUES
\fBre_compile_pattern\fR returns an error message if it fails.
\fBre_match\fR returns the number of matching characters, or -1
if there is no match.
\fBre_search\fR returns the index of the first character in the
string which matches the regular expression, or -1 if there
is no match.
.SH LIBRARY
libstock.a
.SH DIAGNOSTICS
See the complete documentation.
.SH "SEE ALSO"
.nf
.fi
.SH "BUGS AND CAVEATS"
Empty branches and empty regular expressions are not portable to V8.
.LP
The restriction against
applying `*' or `+' to a possibly-null operand is an artifact of the
simplistic implementation.
.LP
Does not support
egrep's
newline-separated branches;
neither does the V8
regexp(3),
though.
.LP
Due to emphasis on
compactness and simplicity,
it's not strikingly fast.
It does give special attention to handling simple cases quickly.
.LP
This version is not MT-safe.
.SH AUTHOR
.LP
The code for
was written at the University of Toronto
and appeared in \fI4.3 tahoe\fR.
It was intended to be compatible with the Bell V8
regexp (3),
but is not derived from Bell code.

.\" $Id: dsap_regex.3,v 1.1 1997/07/21 00:41:27 danq Exp $ 
