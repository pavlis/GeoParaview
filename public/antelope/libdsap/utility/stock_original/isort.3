.\" $Name $Revision: 1.1.1.1 $ $Date: 1997/04/12 04:19:00 $


.TH ISORT 3 "$Date: 1997/04/12 04:19:00 $"
.SH NAME
isort \- insertion sort implementation
.SH SYNOPSIS
.nf
void isort ( char *a, int n, int size, int (*compare)(), void *private );
.fi
.SH DESCRIPTION
This is an implementation of an insertion sort, taken from 
\fIAlgorithms in Modula-3\fR by Robert Sedgewick, pp 100.  
This is a good sort for short lists or lists that are almost ordered. 
.LP
A is the array to be sorted, n is the number of elements in the array, 
size is the size (in bytes) of an element of the array, compare is a comparison
routine which is called as follows:
.nf
(*compare) ( element1, element2, private ) 
.fi
where element1 and element2 are pointers to elements of the array, and
private is whatever you like (which may be nothing).
On the other hand, \fIa\fR might be an array of indexes into a second 
array which is given by private.
Compare should return an integer which is (<0, ==0, >0) when
(*element1 < *element2, *element1 == *element2, *element1 > *element2 ). 
.LP
\fBIsort\fR sorts the array in memory by moving the elements of the
array.
.SH EXAMPLE
.nf
    #include "stock.h"
    #include <stdio.h>

    int ccmp ( a, b, private ) 
    char *a, *b ; 
    void *private ; 
    { 
        return *a-*b ; 
    }

    int
    main()
    {
        char        aline[STRSZ] ;

        while ( gets(aline) ) { 
                printf ( "input : %s\en", aline ) ; 
                isort ( aline, strlen(aline), 1, ccmp, 0 ) ;
                printf ( "sorted: %s\en", aline ) ; 
              }
        return 0;
    }

.fi
.SH RETURN VALUES
none
.SH LIBRARY
libstock.a
.SH DIAGNOSTICS
none
.SH "SEE ALSO"
.nf
shellsort(3), qsort(3)
.fi
.SH "BUGS AND CAVEATS"
.SH AUTHOR
Daniel Quinlan

.\" $Id: isort.3,v 1.1.1.1 1997/04/12 04:19:00 danq Exp $ 
